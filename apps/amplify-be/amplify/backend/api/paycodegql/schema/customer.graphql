#NOTE:
# if queries such as "all queries sent by me", "all queries sent to me", "all queries sent by me by particular user", "all queries I sent to particular user", are useful in your app, we can write custom resolver that answer these cost effectively.
#note:due to efficiency reasons, while we can implement the following within @User model, we won't do it: `transfersSent: [Transfer] @hasMany(indexName: "bySender", fields: ["id"])`
# In general, the bySender index is not efficient as it requires filtering by username sent to answer queries such as "all transfer I made to a particular username". The underlying DDB data source must first grab all transaction by the User (costing you RCU) then filter it.
# A more efficient querying can be achieved by with the ff indexes in Transfer but we can't use the @hasMany in User (instead we will use custom queries) and the reason is there is something called range operations on queries in DDB (begin_with in this case) that allows us to target items that begin with the username in the "to" field in this case, allowing for potentially much smaller number of RCUs used (it doesn't fetch and filter for the result, but only grab what it needs). That is why, if the queries above are super important, the following are a must in the Transfer model for a cost effective querying:
# toFrom: @index (name: "bySenderTo", sortKeyFields: ["createdAt", "status"])
# toFrom: @index (name: "byReceiverFrom", sortKeyFields: ["createdAt", "status"])
# Also note that we can't implement the following:
# transfersReceived: [Transfer] @hasMany(indexName: "byReceiver", fields: ["id"])
# this is b/c the owner field of those senders is not the owner of the receiver. There are implementation issues too long to explain here (ask me)

#Note, the primary key should be the same as the cognito username and passed as sub:username in the JWT  (we do not auto generated ID here to avoid reverse lookup each time the user logs in to find out the app layer username and match it with the cognito username)

#Inline auth is necessary to block a user from editing the owner field , which is auto generated by the system

#using username instead of auto generated IDs for User and Profile to minimize unnecessary calls to the be
type User @model @auth(rules: [{ allow: owner, ownerField: "username" }]) {
  username: String!
    @primaryKey
    @auth(
      rules: [
        { allow: owner, ownerField: "username", operations: [create, read, delete] }
      ]
    )
  email: String!
  profile: Profile @hasOne
  notifications: [Notification] @hasMany
}

type Profile @model @auth(rules: [{ allow: owner, ownerField: "username" }]) {
  username: String!
    @primaryKey
    @auth(
      rules: [
        { allow: owner, ownerField: "username", operations: [create, read, delete] }
      ]
    )
  bio: String
  user: User @belongsTo(fields: ["username"])
}

type Notification
  @model
  @auth(rules: [{ allow: owner, ownerField: "username" }]) {
  id: ID!
  username: String!
    @auth(
      rules: [
        { allow: owner, ownerField: "username", operations: [create, read, delete] }
      ]
    )
  title: String!
  message: String!
  read: Boolean!
  user: User @belongsTo(fields: ["username"])
}

type Transfer @model @auth(rules: [{ allow: owner, ownerField: "from" }]) {
  id: ID!
  from: String!
    @auth(
      rules: [{ allow: owner, ownerField: "from", operations: [create, read, delete] }]
    )
  to: String!
  #read the note above ->the ff can support efficient querying using custom query type
  # toFrom: @index (name: "bySenderTo", sortKeyFields: ["createdAt", "status"])
  # toFrom: @index (name: "byReceiverFrom", sortKeyFields: ["createdAt", "status"])
  # note that you would need to insert createAt manually (the auto generated field would have worked but the graphql compiler most likely will flag it as the auto generation happens in the resolvers)
  # and also you don't need to project 'to' and 'from' in the index, as it is already in the partition keys
  amount: Float!
  status: TransferStatus!
}

enum TransferStatus {
  COMPLETED
  FAILED
  REJECTED
  PENDING
}

#custom query example (the lambdas implement these custom resolvers)
# type Query {
#   transfersBySender(senderId: ID!): [Transfer] @function(name: "queryTransfersBySender-${env}")
#   transfersByReceiver(receiverId: ID!): [Transfer] @function(name: "queryTransfersByReceiver-${env}")
# }

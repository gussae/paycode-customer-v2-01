# High Level User Guide

## Adding a Feature

- As examples, this guide covers the addition of QR code generation (through `paycode-proxy`) and document storage functionality (via GraphQL).

### UI Development

- To leverage the typescript ecosystem tooling, use  `@ui-web` over `@web-ui`. It employs the `Demo` application within `amplify-be` for testing and demonstration of the component across all utilized resources.
- Update `@ui-component` by introducing `Qrcode.tsx` and `Document.tsx`. Export them from the `Demo/index.ts`. Design these components (see examples in the Demo folder) to employ generic backend access methods, which are provided in `App.tsx` through the actual methods generated by `@utils`. This enables interactions with both the document-store (via GraphQL) and the paycode-proxy (via API Gateway), ensuring components remain independent of the specific hydration system for broader workspace applicability.
- To add these features, import the developed UI components (`Qrcode.tsx` and `Document.tsx`) into `App.tsx` of `ui-web`.
- After ensuring `@utils` is updated (this will happen at later stage), import the methods `listDocuments`, `uploadDocument`, and `deleteDocument` for document-store operations, along with `generateQrcode` for QR code generation, into the components.

### Adding the QR Code Resource to Paycode-Proxy

- **Add a QR Code Endpoint**: Add a new QR code endpoint and the corresponding Lambda function within `@paycode-proxy/fn`. This addition necessitates updates to the OpenAPI specification and the associated client.

  - **API Resource Configuration**:
      **Integration Setup**: In the `integration.yaml` file, replicate an existing code block and modify it to establish a connection with the backend Lambda through the URI `arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${QrcodeFunction.Arn}/invocations`. Utilize the existing `ApiInvokeLambdaRole` for Lambda invocation permissions, or introduce a new role as needed within `template.build.yaml`.
      **Model Definitions**: Precisely outline the request and response schemas for QR code operations in `models.yaml`. This step is crucial for establishing transparent and accurate exchanges between the frontend and backend.

      **Path Configuration**: Detail the API paths in `method-defs.yaml`, referencing the integration, along with the request and response models defined previously. To streamline this process, duplicate an existing path configuration and adjust as necessary. It's essential that the request and response models align with those specified in `models.yaml`. Additionally, ensure that parameter validation is enabled by setting the validation to `validateBody`. Note that, `postQrcode` is a resource creation operation (it's not idempotent so GET operation sounds wrong, and you are technically creating a resource). As such the request uses `Post` operation and the response is a 202 status code

      **ATTENTION**: the `api-adapter` uses regex to capture the HTTP/API methods. It looks for GET|POST|PUT|DELETE|OPTIONS in the API.ts. The operationId is used by the client generator. While the client generator can handle this, the `api-adapter` will not be able to pick this up and you won't find `generateQrcode` on the `api-adapter`. However, if you use `postQrcode`, u will find it. Hence, the `operationId` should be postQrcode and not generateQrcode! Also, note that, the first time you build the new client, it may fail as the types used in `Qrcode.ts` may not be available till the build finishes. This should fix itself on the next run (or you could start by using the apigw utils to generate the client first)

  - integrations.yaml

      ```yaml
      Qrcode:
        type: aws_proxy
        credentials:
          Fn::GetAtt: ["ApiInvokeLambdaRole", "Arn"]
        httpMethod: POST
        uri:
          Fn::Sub: 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${QrcodeFunction.Arn}/invocations'
        passthroughBehavior: 'when_no_match'

      ```

  - models.yaml

      ```yaml
        PostQrcodeRequest:
          type: object
          properties:
            username:
              type: string
              description: The username to generate a QR code for.

        PostQrcodeResponse:
          type: object
          properties:
            qrcodeUrl:
              type: string
              description: URL of the generated QR code.
      ```

  - method-defs.yaml

      ```yaml
      /qrcode:
          post:
            summary: Generate QR Code
            operationId: postQrcode #!important
            requestBody:
              required: true
              content:
                application/json:
                  schema:
                    $ref: './models.yaml#/PostQrcodeRequest'
            responses:
              '202':
                description: Successful payment
                content:
                  application/json:
                    schema:
                      $ref: './models.yaml#/PostQrcodeResponse'
            security:
              - CognitoAuthorizer: []
              - api_key: []
              - sigv4: []
            x-amazon-apigateway-request-validators: "validateBody"
            x-amazon-apigateway-integration:
              $ref: './integrations.yaml#/Qrcode'
          options:
            $ref: './cors.yaml#/Options'
      ```

    - There's no need to modify `openapi.spec.yaml` as it serves to compile distributed files into a cohesive specification. CORS settings are pre-configured, and the `bundle-api.js` script consolidates these into `openapi.bundled.yaml`, readying it for the build stage.

  - **Setting Up the Resource Handler Lambda in `@paycode-customer-v2/paycode-proxy/fn`**:
    - Start by creating a new directory named `qrcode` rather than copying and renaming an entire existing workspace, which could lead to issues with file monitoring in your project. Then, copy the contents of the `payment` directory into this new `qrcode` directory. Subsequently, rename the workspace and update the lambda handler from `postBalance` to `postQrcode`, and rename `payment.ts` to `qrcode.ts`, implementing only minor adjustments. See [qrcode](../apps/paycode-proxy/fn/qrcode/src/index.ts).
    - To validate your lambda's functionality, use `execute-check.ts`. This should initiate a source check followed by a bundle check, with both verifying a mock QR code URL is returned. Notably, the lambda handler is designed to add CORS headers when invoked from a browser, illustrating:

    ```js
    {
      statusCode: 200,
      body: '{"qrCodeUrl":"https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=Username:test"}',
      headers: { 'Content-Type': 'application/json' }
    }
    ```

    - For the lambda infrastructure outlined in `template.build.template`, incorporate the specified configuration, ensuring the `QrcodeFunction` name aligns with the logical resource identified in `integration.yaml`. The npm script

    ```"build": "tsc && tsc-alias && esbuild src/index.ts --bundle --platform=node --target=node18 --outdir=dist \"--external:@aws-sdk/*\"```,

    compiles the lambda into the `qrcode/dist` directory. This build process integrates global environment variables, runtime settings, and specific configurations shared across lambdas. These environment variables are managed through `@config` and can be modified within `.monorepo.config.json` at the project's root or `.workspace.config.json` in the paycode-proxy workspace. The script `build-template.js` plays a crucial role in integrating these configurations into the lambda's environment variables. For details, consult the [Configuration System](Project%20Overview.md#configuration-system).

    ```yaml
      QrcodeFunction:
        Type: AWS::Serverless::Function
        Properties:
          CodeUri: fn/qrcode/dist/
          VpcConfig:
            SubnetIds:
              - !Ref SubnetA
              - !Ref SubnetB
            SecurityGroupIds:
              - !Ref SecurityGroup
    ```

    Add invoke access to the qrcode to the `LambdaInvokePolicy` within  `ApiInvokeLambdaRole` role:

    ```yaml
     Policies:
        - PolicyName: LambdaInvokePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource:
                  - !GetAtt BalanceFunction.Arn
                  - !GetAtt TransactionFunction.Arn
                  - !GetAtt PaymentFunction.Arn
                  - !GetAtt QrcodeFunction.Arn
    ```

- Integrating a new feature requires adding a corresponding client, a task made easier with the `api-adapter`. In `@utils/src/browser/paycode-proxy-api`, create `qrcode.ts` and ensure its export through `index.ts`. Using `getApiAdapter` yields an adapter configured to access the `generateQrcode` client. Unlike direct use of `postQrcode`, which needs further setup and Axios interception, the `api-adapter` and `builder` in `@utils` streamline this. Given the client relies on `openapi.bundled.yaml`, modify the API before this step. Once done, build `@utils` for UI integration.

    ```js
      import { GenerateQrcode202, GenerateQrcodeBody, getApiAdapter } from './client';

      // API Gateway integration
      export async function genQrcode(
        params: GenerateQrcodeBody,
      ): Promise<GenerateQrcode202> {
        console.log(6614, params.username);
        const proxyApi = await getApiAdapter();
        const result = await proxyApi.generateQrcode(params);
        console.log(6654, 'Generated Qrcode', result.data);
        return result.data;
      }

    ```

 At this point, you want to check the FE by running `npm run dev` to see the change. Also, incorporate it into a jest test in `@utils`. See [Paycode API Adapter TEST](../packages/utils/test/paycode-api-adapter.test.js) for an example.

### Document Store Implementation in GraphQL

Integrating features via GraphQL involves a distinct approach centered around effective modeling.

- **Create Model**: For instance, (refer to [document.graphql](../apps//amplify-be/amplify/backend/api/paycodegql/schema/document-index.graphql))the `DocumentIndex` model facilitates secure and efficient document management. It's defined with `@model` to support operations such as retrieving (`getDocumentIndex`, `listDocumentIndexes`) and managing document indices (`createDocumentIndex`, `deleteDocumentIndex`) within DynamoDB, initiated by S3 events. This model does not include subscriptions, fitting the project's scope but remains extendable for future enhancements like event listeners for document or index updates.

Authorization is managed via the `@auth` directive, restricting access to documents based on the `username` of the owner. The model accommodates multiple buckets, though Amplify uses one, and introduces the `dirname` concept for potential future developments, such as user-defined folders.

- **Custom Resolvers**: Key to this feature are the custom resolvers: `documentAccess`, `documentIndex`, and `removeDocument`.
  - The `documentAccess` resolver generates signed URLs for document uploads and downloads, enabling the frontend to directly interact with S3.
  - `documentIndex` handles the creation or deletion of document indices in DynamoDB in response to S3's `putObject` and `deleteObject` events, illustrating an event-driven architecture that boosts robustness and maintainability.
  - `removeDocument` facilitates the removal of documents from S3.

These resolvers are crucial for generating signed URLs for document management, directly leveraging AWS Lambda via AppSync integration for operations without intermediary backend processing.

- **Frontend Client Implementation**: To utilize this setup, the frontend needs capabilities to handle signed URLs for direct S3 interactions. See the implementation in [document.ts](../packages/utils/src/browser/paycode-gql/document.ts), which illustrates how to integrate these operations into the UI effectively. Note that the `@utils` package manages the `document.ts` client, which is then imported in the `@ui-web` workspace and used in the UI.

### Adding a New Service

MSA often poses more challenges than benefits for small teams. Yet, as your system grows, migrating to MSA might become advantageous. The current setup is already tailored for an easy transition to MSA, designed with scalability in mind and pared down to meet your team's immediate needs. Should you decide to embark on this transition independently, replicating the `@paycode-proxy` framework to kick-start a new service is recommended. I can forward a detailed guidance for shifting to a microservices architecture (MSA) whenever you're ready. Note that, the `@paycode-proxy` configuration currently functions as a service proxy. For a full-fledged MSA, incorporating state and event management is essential. Utilizing `DynamoDB` for NoSQL patterns simplifies this process, especially since its native feature, DynamoDB streams, seamlessly supports event distribution to an event bus.

### Deployment

- **GitHub Integration**: Push your code to GitHub for seamless CI/CD. See [CI/CD section](Project%20Overview.md#ci-cd) of the project overview.
- **Local Deployment**:
  - In the `@paycode-proxy` workspace, run `npm run build` to prepare the deployment environment. This command bundles the API, processes `template.build.yaml`, and carries out the API deployment, among other essential steps. For comprehensive guidance, visit the [Proxy Workspace Scripts Section](Project%20Overview.md#paycode-proxy-workspace-scripts). It's critical to ensure that `openapi.bundled.yaml`, `template.yaml`, and `samconfig.toml` are accurately updated as per the deployment checklist.
  - Similar actions are required for the `@ui-web` workspace. Running `npm run build` configures the deployment setting, builds, and deploys static files to S3/CloudFront, followed by a CloudFront cache invalidation to reflect the latest changes.
- **API Testing**:
  - To evaluate the deployed API, you can access it via the AWS console or employ `@utils/node/apigw-utils/export-apigw` (or its npm script) to export the OpenAPI YAML. It outputs a yaml file which you can use with Postman or similar solutions. You would need to have a valid JWT token to access the API and you can grab this from the debug console. Ensure this is turned off in production.

### Generating Documentations

As your project grows with new features, updating your documentation accordingly is vital to maintain clarity and usefulness. Within `@utils`, the `src/node/generate-docs` script is designed to create comprehensive documentation for both GraphQL and browser clients (apigw and graphql clients abstracted for sharing across web apps). While it's feasible to generate TypeScript documentation, focusing on providing frontend developers with detailed information about available GraphQL and API Gateway clients is considered more beneficial and efficient. To generate this documentation, execute `npm run doc` either from the monorepo root or directly within the `@utils` workspace. Running this script from the monorepo root is recommended, as it ensures the `@utils` workspace is built prior to documentation generation, thereby streamlining the process.You can find the output in the `/docs` directory along with this documentation and the READEME.md file.

## Development and Maintenance Guide/Tips

### Workspace/Package Management

The project harnesses the power of npm workspaces to merge simplicity with functionality. A solid grasp is essential for effective utilization—missteps can lead to complications. Dive into the [Npm Workspaces guide](https://docs.npmjs.com/cli/v8/using-npm/workspaces) for a thorough understanding.

Creating workspaces, packages, apps, or services is straightforward—duplicate and tweak the necessary files from existing workspaces. This method swiftly integrates new components while keeping the project organized. While the `--workspace` flag allows for dependency addition, using `npm run install` from the project root is recommended to ensure correct dependency installation. Dependencies, hoisted at the root, streamline package management. For uniform version management across workspaces, consider updating dependencies from the root using [NCU](https://www.npmjs.com/package/npm-check-updates).

For TypeScript projects, project references can significantly reduce unnecessary builds, boosting efficiency. This setup eliminates the need to rebuild dependencies like `@utils` or `@ui-components` during development.

### Managing Amplify-Be Environment

The `amplify-be` environment is central to backend service management. In complex setups, differentiating production and development environments protects live data. Environment adjustments are simplified with the Amplify CLI—[see documentation](https://docs.amplify.aws/javascript/tools/cli/teams/). A Git hook facilitates environment switching in `amplify-be`, aligning the active environment with Amplify commands. While environment swapping without branch changes is possible via `amplify env checkout <env-name>`, it's generally advised against due to potential access errors and complications. Should you need to, `npm run switch-env` in `amplify-be` can redirect your environment temporarily. Always revert to the appropriate setting post-operation.

### Migrating to a Different Deployment Environment

Transitioning to a new deployment environment is straightforward—update `.monorepo.config.json` with the desired `deploymentEnv`. This project is designed for flexible deployment across environments, making infrastructure migration effortless. Data migration, however, should follow AWS guidelines for best practices.

## Misc Notes

- **Cost-Effective Architecture**: This serverless setup cuts costs on idle resources. Continuously evaluate the cost ramifications of future architectural decisions.
- **Scalability and Security**: The architecture supports seamless integration of new features, making it well-suited for outsourced development. External contributions can be efficiently managed through pull requests, ensuring no direct backend access is required. This setup allows for organizing features into buckets, enabling streamlined sprints and subsequent merges into the development branch.
- **Local Development Scripts**: Leverage workspace scripts for efficient local development.
- **Documentation and Code Generation**: I have to note this: leverage ChatGPT-4, Gemini, CodeWhisperer, and/or GitHub Copilot for swift documentation and code generation tasks. For AWS-specific documentation and insights, Amazon Q is a remarkable resource. While not infallible, the accuracy and breadth of knowledge these tools offer regarding AWS and broader development topics are substantial.

### Major TODOs

The project is dotted with todos, with prioritization varying by necessity:

- **Authorization Layer**: A robust app authorization layer is needed for enhanced security, beyond the current username validation.
- **AWS SDK Lambda Layer**: Creating a lambda layer for the AWS SDK can standardize version control, vital for security and maintenance as function complexity increases.

Please leverage a todo extension for tracking todos. Many are of low priority and reflect initial observations. For critical todos, it's advisable to either create issues or address them promptly.

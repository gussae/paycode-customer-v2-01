# Example Document implementation (starter)
#* Note: deleteDocument metadata will trigger lambda which will remove the object from  the S3 and  uploadDocument putObject will trigger lambda the will use createMutation to save metadata to DDB. Such event orchestration is more robust and easier to maintain compared to using sync transactional operations in the resolver
type DocumentIndex
  @model(
    #? get & list only and deal with metadata in the Document DDB
    queries: { get: "getDocumentIndex", list: "listDocumentIndexes" }
    mutations: { create: "createDocumentIndex", delete: "deleteDocumentIndex" }
    subscriptions: null #* no subscriptions for now
  )
  @auth(rules: [{ allow: owner, ownerField: "username" }]) {
  #object key path in the S3 bucket is {username}/{dirname}{filename}.
  username: String! @primaryKey(sortKeyFields: ["key"])
  key: String! @index(name: "byKey", sortKeyFields: ["version"])
  bucketName: String! #allows supporting multiple buckets
  dirname: String! #This is app layer construct and you can progressively add more features such user created folders. By abstracting this in the app layer, the document structure can remain stable.
  filename: String!
  entityType: EntityType!
  eTag: String #S3 eTag (hash of content or hash of hash of parts in case of multipart upload)
  extension: String! #file extension
  mimetype: String! #using this instead of contentType as it is used in http headers
  size: Float! #in kilobytes
  storageClass: StorageClass
  tags: [String] #tags for search and categorization
  ttl: Int #Epoch time when this item should expire
  version: String!
  user: User
    @belongsTo(fields: ["username"])
    @auth(
      rules: [
        {
          allow: owner
          ownerField: "username"
          operations: [create, read, delete]
        }
      ]
    )
}

enum EntityType {
  BILLING
  DOCUMENT
  HISTORY
  RECEIPT
  PROFILE
}

enum StorageClass {
  DEEP_ARCHIVE
  EXPRESS_ONEZONE
  GLACIER
  GLACIER_IR
  INTELLIGENT_TIERING
  ONEZONE_IA
  OUTPOSTS
  REDUCED_REDUNDANCY
  SNOW
  STANDARD
}

#Document Access
# Access is controlled via signedUrls generated by the documentAccess function which returns a signedUrl and metadataHeaders.

type Query {
  getDownloadDocumentAccess(params: DownloadDocumentAccessInput): DownloadDocumentAccess
    @function(name: "documentAccess-${env}")
  getUploadDocumentAccess(params: UploadDocumentAccessInput): UploadDocumentAccess
    @function(name: "documentAccess-${env}")
}

type Mutation {
  removeDocument(params: RemoveDocumentInput): RemoveDocumentResponse
    @function(name: "removeDocument-${env}")
}

enum S3Operation {
  GET
  PUT
}

input UploadDocumentAccessInput {
  dirname: String!
  filename: String!
  entityType: EntityType!
  expiry: Int
  mimetype: String!
  operation: S3Operation!
  ttl: Int
  tags: [String]
  username: String!
}

input DownloadDocumentAccessInput {
  dirname: String!
  filename: String!
  expiry: Int
  username: String!
  version: String
  operation: S3Operation!
}

input RemoveDocumentInput {
  dirname: String!
  filename: String!
  username: String!
  versionId: String
}

type DownloadDocumentAccess {
  signedUrl: String!
}

type UploadDocumentAccess {
  signedUrl: String!
  metadataHeaders: AWSJSON
}

type RemoveDocumentResponse {
  success: Boolean!
  message: String
}
